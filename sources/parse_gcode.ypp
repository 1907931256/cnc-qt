/* -*-c++-*- */

%{
/*
 * parse_gcode.y - parser for a GCODE data file
 *
 * Copyright (C) 2018 Eduard Kalinowski <eduard_kalinowski@yahoo.de>
 *
 * This is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this package; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 51 Franklin Street - Fifth Floor,
 * Boston, MA 02110-1301, USA.
 *
 * $Id$
 *
 */

#if HAVE_CONFIG_H
# include <config.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define YYERROR_VERBOSE 42
#define YYDEBUG 1
#define YYMAXDEPTH 1000000

#define __NOEXTENSIONS__ 1


#include <QString>
#include <QChar>
#include <QDebug>


#include "GCode.h"

extern int gcode_lex();
extern int gcode_scan_buf(char *base);
extern void gcode_error(char*);

// static int gcodelineno = 0;
extern int gcode_lineno;
static int gcodecharno = 0;

// gcode_lineno = 0;

// init of first gcode data
GCodeData *g_data = new GCodeData();


%}

%name-prefix "gcode_"

%token T_CMD
%token T_ANGLE
%token T_FEED
%token T_RADIUS
%token T_LABEL
%token T_ARC
%token T_COORD
%token T_COMMENT
%token T_CHANGETOOL
%token T_DIAMETER
%token T_PAUSE
%token T_PAUSESEC

%token InvalidCharacter
%token Eol


%union {
    int       i_val;
    float     f_val;
    char     *s_val;
}


%token <i_val> Num
%token <f_val> Real
%token <s_val> Strg



%start parse_gcode

%%

parse_gcode: 
        | glines;

glines: glines gline | gline;

gline:  T_LABEL commands 
        {
            // the new line, create new object
            GCodeParser::gCodeList << g_data;
            g_data = new GCodeData(g_data);
            g_data->numberLine = gcode_lineno;
            
            QString n = &gcode_lval.s_val[1];
            bool res;
            int i = n.toInt(&res);
            g_data->labelNum = i;
        }
        | T_LABEL params 
        {
            // the new line, create new object
            GCodeParser::gCodeList << g_data;
            g_data =  new GCodeData(g_data);
            g_data->numberLine = gcode_lineno;
            
            QString n = &gcode_lval.s_val[1];
            bool res;
            int i = n.toInt(&res);
            g_data->labelNum = i;
        }
        | commands 
        | comment 
        | params 
        {
            // the new line, create new object
            GCodeParser::gCodeList << g_data;
            g_data =  new GCodeData(g_data);
            g_data->numberLine = gcode_lineno;
        }
        ;
     
commands: commands command 
        | command;

command: T_CMD
        {
            QString n = &gcode_lval.s_val[1];
            bool res;
            int i = n.toInt(&res);
            if (res == false) {
                g_data->decoded = false;
                return -1;
            }
            // the new line, create new object
            GCodeParser::gCodeList << g_data;
            g_data =  new GCodeData(g_data);
            g_data->numberLine = gcode_lineno;
            
            if ((gcode_lval.s_val[0] | 0x20) == 'g'){
                g_data->gCmd = i;
                g_data->mCmd = -1;
            }
            if ((gcode_lval.s_val[0] | 0x20) == 'm'){
                g_data->mCmd = i;
                g_data->gCmd = -1;
            }
        }
        | T_CMD params
        {
            QString n = &gcode_lval.s_val[1];
            bool res;
            int i = n.toInt(&res);
            if (res == false) {
                g_data->decoded = false;
                return -1;
            }
            // the new command, create new object
            GCodeParser::gCodeList << g_data;
            g_data =  new GCodeData(g_data);
            g_data->numberLine = gcode_lineno;
            
            if ((gcode_lval.s_val[0] | 0x20) == 'g'){
                g_data->gCmd = i;
                g_data->mCmd = -1;
            }
            if ((gcode_lval.s_val[0] | 0x20) == 'm'){
                g_data->mCmd = i;
                g_data->gCmd = -1;
            }
        }
        | T_CMD params comment
        {
            QString n = &gcode_lval.s_val[1];
            bool res;
            int i = n.toInt(&res);
            if (res == false) {
                g_data->decoded = false;
                return -1;
            }
            // the new command, create new object
            GCodeParser::gCodeList << g_data;
            g_data =  new GCodeData(g_data);
            g_data->numberLine = gcode_lineno;
            
            if ((gcode_lval.s_val[0] | 0x20) == 'g'){
                g_data->gCmd = i;
                g_data->mCmd = -1;
            }
            if ((gcode_lval.s_val[0] | 0x20) == 'm'){
                g_data->mCmd = i;
                g_data->gCmd = -1;
            }
        }
        ;

params: params param | param;

param:  T_COORD
        {
            QString s = &gcode_lval.s_val[1];
            
            bool res;
            float f = s.toFloat(&res);
            if (res == false) {
                g_data->decoded = false;
                return -1;
            }
            
            if ((gcode_lval.s_val[0] | 0x20) == 'x'){
                g_data->baseCoord.setX(f);
            }
            if ((gcode_lval.s_val[0] | 0x20) == 'y'){
                g_data->baseCoord.setY(f);
            }
            if ((gcode_lval.s_val[0] | 0x20) == 'z'){
                g_data->baseCoord.setZ(f);
            }
        }
        | T_ANGLE
        {
            QString s = &gcode_lval.s_val[1];
            bool res;
            float f = s.toFloat(&res);
            if (res == false) {
                g_data->decoded = false;
                return -1;
            }
            
            g_data->useExtCoord = ABC;
            if ((gcode_lval.s_val[0] | 0x20) == 'a'){
                g_data->extCoord.setX(f);
            }
            if ((gcode_lval.s_val[0] | 0x20) == 'b'){
                g_data->extCoord.setY(f);
            }
            if ((gcode_lval.s_val[0] | 0x20) == 'c'){
                g_data->extCoord.setZ(f);
            }
        }
        | T_PAUSESEC
        {
            QString s = &gcode_lval.s_val[1];
            bool res;
            float f = s.toFloat(&res);
            if (res == false) {
                g_data->decoded = false;
                return -1;
            }
            if (g_data->gCmd == 4){
                g_data->pauseMSec = f*1000.0;
            }
        }
        | T_PAUSE
        {
            QString s = &gcode_lval.s_val[1];
            bool res;
            float f = s.toFloat(&res);
            if (res == false) {
                g_data->decoded = false;
                return -1;
            }
            if (g_data->gCmd == 4){
                g_data->pauseMSec = f;
            }
        }
        | T_DIAMETER
        {
            QString s = &gcode_lval.s_val[1];
            bool res;
            float f = s.toFloat(&res);
            if (res == false) {
                g_data->decoded = false;
                return -1;
            }
            g_data->toolDiameter = f;
        }
        | T_CHANGETOOL
        {
            QString s = &gcode_lval.s_val[1];
            bool res;
            float f = s.toFloat(&res);
            if (res == false) {
                g_data->decoded = false;
                return -1;
            }
            g_data->toolChange = true;
            g_data->toolNumber = f;
        }
        | T_FEED
        {
            QString s = &gcode_lval.s_val[1];
            bool res;
            float f = s.toFloat(&res);
            if (res == false) {
                g_data->decoded = false;
                return -1;
            }
            g_data->rapidVelo = f;
        }
        | T_RADIUS
        {
            QString s = &gcode_lval.s_val[1];
            bool res;
            float f = s.toFloat(&res);
            if (res == false) {
                g_data->decoded = false;
                return -1;
            }
            g_data->radius = f;
        }
        | T_ARC 
        {
            QString s = &gcode_lval.s_val[1];
            bool res;
            float f = s.toFloat(&res);
            if (res == false) {
                g_data->decoded = false;
                return -1;
            }
            
            g_data->useExtCoord = IJK;
            if ((gcode_lval.s_val[0] | 0x20) == 'i'){
                g_data->extCoord.setX(f);
            }
            if ((gcode_lval.s_val[0] | 0x20) == 'j'){
                g_data->extCoord.setY(f);
            }
            if ((gcode_lval.s_val[0] | 0x20) == 'k'){
                g_data->extCoord.setZ(f);
            }
        }
        ;
      
comment: T_COMMENT
        {
        }
        | T_COMMENT Strg
        {
            qInfo() << "comment" << $2;
            free ($2);
        }
        | '(' Strg ')'
        {
            qInfo() << "comment" << $2;
            free ($2);
        }
        ;
        
%%

int gcode_error (const char * error) {
  fprintf (stderr, "line %d: %s\n", gcode_lineno, error);
  return 0;
}
