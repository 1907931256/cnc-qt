/* -*-c++-*- */

%{
/*
 * parse_gcode.ypp - parser for a GCODE data file
 *
 * Copyright (C) 2018 Eduard Kalinowski <eduard_kalinowski@yahoo.de>
 *
 * This is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this package; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 51 Franklin Street - Fifth Floor,
 * Boston, MA 02110-1301, USA.
 *
 * $Id$
 *
 */

#if HAVE_CONFIG_H
# include <config.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define YYERROR_VERBOSE 42
#define YYDEBUG 1
#define YYMAXDEPTH 1000000

#define __NOEXTENSIONS__ 1


#include <QString>
#include <QChar>
#include <QDebug>


#include "Settings.h"


#include "GCode.h"

// // static int gcodelineno = 0;
extern int gcode_lineno;
static int gcodecharno = 0;

extern int gcode_parse (void);
extern void gcode_error (const char *c);
extern int gcode_lex (void);
extern int gcode_lex_destroy (void);


bool set_data_float(char c, float f);

// gcode_lineno = 0;

GCodeData *gcode_data;

%}

%name-prefix "gcode_"


%token NL_CHAR
%token CHAR
%token COMMENTAR
%token VAR_DEF
%token VARIABLE
%token NEW_LINE
%token INT
%token FLOAT
%token EQUAL 


%token InvalidCharacter


%token Eol

%left '*' '/' 
%left EQ NE GT LT GE LE

%union {
    int       i_val;
    float     f_val;
    char      c_val;
    char*     s_val;
}


%type <i_val> INT
%type <f_val> FLOAT
%type <c_val> NL_CHAR CHAR
%type <s_val> COMMENTAR VAR_DEF VARIABLE expr


%start parse_gcode

%%

parse_gcode: 
        | glines
        ;


glines: gline glines
        | gline
        ;


gline:  NL_CHAR INT
        {
            // the new line, create new object
            // for cases, when line begins with g, m command or n: label
            if (GData::dataVector.count() == 0){
                gcode_data = new GCodeData();
            }
            else {
                gcode_data = new GCodeData(gcode_data);
            }
            gcode_data->numberLine = gcode_lineno;

            switch ($1 | 0x20){
                case 'n' :
                    gcode_data->labelNum = $2;
                    break;

                case 'g' :
                    gcode_data->gCmd = $2;
                    switch ($2){
                        case 0:
                            gcode_data->movingCode = RAPID_LINE_CODE;
                            break;
                            
                        case 1:
                        case 2:
                        case 3:
                            gcode_data->movingCode = FEED_LINE_CODE;
                            break;
                            
                        case 17:
                            gcode_data->plane = XY;
                            break;
                            
                        case 18:
                            gcode_data->plane = YZ;
                            break;
                            
                        case 19:
                            gcode_data->plane = ZX;
                            break;
                    }
                    break;

                case 'm' :
                    gcode_data->gCmd = -1;
                    gcode_data->mCmd = $2;
                    break;
 
                default:
                    // not decoded, it's possible other code? 
                    if (set_data_float(($1 | 0x20), (float) $2) == false) {
                        gcode_data->decoded = false;
                        printf("not decoded char %c, line %d\n", $1, gcode_lineno);
                    }
                    break;
            }
        }
        | NL_CHAR FLOAT
        {
            // when line begins with coordinates 
            gcode_data = new GCodeData(gcode_data);
            gcode_data->numberLine = gcode_lineno;
            
            set_data_float(($1 | 0x20), $2);
        }
        | NL_CHAR expr
        {
            // when line begins with coordinates 
            gcode_data = new GCodeData(gcode_data);
            gcode_data->numberLine = gcode_lineno;
            
            gcode_lval.c_val = $1;
        }
        | NL_CHAR
        {
            // store coordinates
        }
        | CHAR INT 
        {
            switch ($1 | 0x20){
                case 'g' : {
                    // new command in line, create new object
                    GData::dataVector << *gcode_data;
                    gcode_data = new GCodeData(gcode_data);
                    gcode_data->numberLine = gcode_lineno;
                    gcode_data->gCmd = $2; 
                    
                    if ($2 == 1 || $2 == 2 || $2 == 3) {
                        gcode_data->movingCode = FEED_LINE_CODE;
                    }
                    if ($2 == 0) {
                        gcode_data->movingCode = RAPID_LINE_CODE;
                    }
                    break;
                }

                case 'm' : {
                    gcode_data->mCmd = $2;
                    break;
                }
 
                default:
                    if (set_data_float(($1 | 0x20), (float) $2) == false) {
                        gcode_data->decoded = false;
                    }
                    break;
            }
        }
        | VAR_DEF expr
        {
        }
        | CHAR FLOAT 
        {
            set_data_float(($1 | 0x20), $2);
        }
        | CHAR expr
        {
            gcode_lval.c_val = $1;
            qInfo() << "char vari" << $1 << $2;
            /*if (GData::dataVaris.contains($5)) {
                set_data_float(($1 | 0x20), $3 * GData::dataVaris[$5]);
            }
            else {
                qCritical() << "definition of variable" << $5 << "not found";
            }*/
        }
        | CHAR
        {
            // store coordinates
        }
        |  VARIABLE '=' FLOAT
        {
            if (GData::dataVaris.contains($1)) {
                qInfo() << "vari" << GData::dataVaris[$1];
                return GData::dataVaris[$1];
            }
            else {
                qCritical() << "definition of variable" << $1 << "not found";
            }
        }
        | COMMENTAR 
        {
           gcode_data->lineComment = QString($1).simplified();
           free($1);
        }
        | NEW_LINE
        {
            if (gcode_data) {
                GData::dataVector << *gcode_data;
            }
        }
        ;

expr:   EQ FLOAT
        {
            qInfo() << $2;
        }
        | FLOAT '*' VARIABLE
        {
            qInfo() <<"expr";
            if (GData::dataVaris.contains($3)) {
                set_data_float((gcode_lval.c_val | 0x20), $1 * GData::dataVaris[$3]);
            }
            else {
                qCritical() << "definition of variable" << $1 << "not found";
            }
        }
        | VARIABLE '*' FLOAT 
        {
            qInfo() <<"other expr";
            if (GData::dataVaris.contains($1)) {
                set_data_float((gcode_lval.c_val | 0x20), $3 * GData::dataVaris[$1]);
            }
            else {
                qCritical() << "definition of variable" << $1 << "not found";
            }
        }
        ;

%%



bool set_data_float(char c, float f) {
    switch (c){
        case 'x':
            gcode_data->baseCoord.setX(f);
            break;
            
        case 'y':
            gcode_data->baseCoord.setY(f);
            break;
            
        case 'z':
            gcode_data->baseCoord.setZ(f);
            break;
            
        case 'i':
            gcode_data->useExtCoord = IJK; // TODO check conflicts
            gcode_data->extCoord.setX(f);
            break;
            
        case 'j':
            gcode_data->useExtCoord = IJK; // TODO check conflicts
            gcode_data->extCoord.setY(f);
            break;
            
        case 'k':
            gcode_data->useExtCoord = IJK; // TODO check conflicts
            gcode_data->extCoord.setZ(f);
            break;
            
        case 'a':
            gcode_data->useExtCoord = ABC; // TODO check conflicts
            gcode_data->extCoord.setX(f);
            break;
            
        case 'b':
            gcode_data->useExtCoord = ABC; // TODO check conflicts
            gcode_data->extCoord.setY(f);
            break;
            
        case 'c':
            gcode_data->useExtCoord = ABC; // TODO check conflicts
            gcode_data->extCoord.setZ(f);
            break;
            
        case 'u':
            gcode_data->useExtCoord = UVW; // TODO check conflicts
            gcode_data->extCoord.setX(f);
            break;
            
        case 'v':
            gcode_data->useExtCoord = UVW; // TODO check conflicts
            gcode_data->extCoord.setY(f);
            break;
            
        case 'w':
            gcode_data->useExtCoord = UVW; // TODO check conflicts
            gcode_data->extCoord.setZ(f);
            break;
            
        case 'r': // radius
            gcode_data->radius = f;
            break;
            
        case 's': // pause sec
            if (gcode_data->gCmd == 4){
                gcode_data->pauseMSec = f*1000.0;
            }
            break;
            
        case 'p': // pause msec
            if (gcode_data->gCmd == 4){
                gcode_data->pauseMSec = f;
            }
            break;
            
        case 'f': // feed
            gcode_data->rapidVelo = f;
            break;
            
        case 'd': // diameter
            gcode_data->toolDiameter = f;
            break;
            
        case 't': // change tool
            gcode_data->toolChange = true;
            gcode_data->toolNumber = f;
            break;
            
        default:
            gcode_data->decoded = false;
            printf("not decoded char %c, line %d\n", c, gcode_lineno);
            return false;
            break;
    }
    return true;
}


void gcode_error (const char * error) {
  fprintf (stderr, "line %d: %s\n", gcode_lineno, error);
//   return 0;
}
