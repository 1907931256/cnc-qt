/* -*-c++-*- */

%{
/****************************************************************************
 * C# to Qt portation, Linux developing                                     *
 * flex/bison G-Code parser                                                 *
 * Copyright (C) 2015-2018 by Eduard Kalinowski                             *
 * Germany, Lower Saxony, Hanover                                           *
 * eduard_kalinowski@yahoo.de                                               *
 *                                                                          *
 * C# project CNC-controller-for-mk1                                        *
 * https://github.com/selenur/CNC-controller-for-mk1                        *
 *                                                                          *
 * The Qt project                                                           *
 * https://github.com/eduard-x/cnc-qt                                       *
 *                                                                          *
 * CNC-Qt is free software; may be distributed and/or modified under the    *
 * terms of the GNU General Public License version 3 as published by the    *
 * Free Software Foundation and appearing in the file LICENSE_GPLv3         *
 * included in the packaging of this file.                                  *
 *                                                                          *
 * This program is distributed in the hope that it will be useful,          *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of           *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            *
 * GNU General Public License for more details.                             *
 *                                                                          *
 * You should have received a copy of the GNU Lesser General Public         *
 * License along with CNC-Qt. If not, see  http://www.gnu.org/licenses      *
 ****************************************************************************/

#if HAVE_CONFIG_H
# include <config.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define YYERROR_VERBOSE 42
#define YYDEBUG 1
#define YYMAXDEPTH 1000000

#define __NOEXTENSIONS__ 1


#include <QString>
#include <QChar>
#include <QDebug>
#include <QVector>


#include "Settings.h"


#include "GCode.h"

extern int gcode_lineno;
static int gcodecharno = 0;

extern int gcode_parse (void);
extern void gcode_error (const char *c);
extern int gcode_lex (void);
extern int gcode_lex_destroy (void);


bool set_data_float(char c, float f);


GCodeData *gcode_data;

%}

%name-prefix "gcode_"


%token NEW_LINE
%token IF
%token ENDIF
%token WHILE
%token ENDWHILE
%token GOTO
%token POW
%token SIN
%token COS
%token SQRT

%token InvalidCharacter


%token Eol


%union {
    int       i_val;
    float     f_val;
    char      c_val;
    char*     s_val;
    class DataOperation* op;
    class GCodeData* g;
}


%token <f_val> FVAL
%token <s_val> SVAL COMMENTAR TERM VARIABLE
%token <i_val> IVAL

%token <c_val> CMD_CHAR PARAM_CHAR LABEL

%type <op>     EXPR

%token SIN_FUNC COS_FUNC POW_FUNC SQRT_FUNC
%token CMP_EQ CMP_LE CMP_GT CMP_LT CMP_GE CMP_NE

%right '='
%left  '-' '+'
%left  '*' '/'
%right '[' 
%left  ']'
%left  UMINUS


%right ELSE 

%start parse_gcode

%%

parse_gcode: 
        | glines
        ;


glines: gline 
        | glines gline 
        ;


gline:  CMD_CHAR IVAL
        {
            // the new line, create new object
            // for cases, when line begins with g, m command or n: label
//             qInfo() << $1 << $2;
            if (GData::dataVector.count() == 0){
                gcode_data = new GCodeData();
            }
            else {
                gcode_data = new GCodeData(gcode_data);
            }
            gcode_data->numberLine = gcode_lineno;

            switch ($1 | 0x20){
                case 'g' :
                    gcode_data->gCmd = $2;
                    gcode_data->mCmd = -1;
                    
                    switch ($2){
                        case 0:
                            gcode_data->movingCode = RAPID_LINE_CODE;
                            break;
                            
                        case 1:
                        case 2:
                        case 3:
                            gcode_data->movingCode = FEED_LINE_CODE;
                            break;
                            
                        case 17:
                            gcode_data->plane = XY;
                            break;
                            
                        case 18:
                            gcode_data->plane = YZ;
                            break;
                            
                        case 19:
                            gcode_data->plane = ZX;
                            break;
                    }
                    break;

                case 'm' :
                    gcode_data->mCmd = $2;
                    break;
 
                default:
                    // not decoded, it's possible other code? 
                    // TODO: not critical message 
                    break;
            }
        }
        | LABEL IVAL 
        {
             gcode_data->labelNum = $2;
        }
        | params
        | vardefs
        | COMMENTAR 
        {
            if (gcode_data == 0){
                gcode_data = new GCodeData();
            }
            if (strlen($1)) {
                gcode_data->lineComment = QString($1).simplified();
                free($1);
            }
        }
        | NEW_LINE
        {
            if (gcode_data) {
                GData::dataVector << *gcode_data;
            }
        }
        ;

vardefs: vardef 
        | vardefs vardef
        ;


vardef: VARIABLE '=' EXPR
        {
            // TODO: check, variable exists?
            if ($3->varType == DATA::FVAL) {
                GData::dataVaris.insert($1, $3->result);
//                 float f = GData::dataVaris[$3->vName];
//                 GData::dataVaris[$3->vName] = f;
//                 qInfo() << "new definition" << $1;
            }
            if ($3->varType == DATA::SVAL) { // TODO
//                 GData::dataVaris.insert($3->vName, $3->result);
//                 qInfo() << $3->result;
            }
        }
        ;


params: param
        | params param
        ;


param:  PARAM_CHAR EXPR
        {
            // when line begins with coordinates 
//             qInfo() << $1 << $2->result;
            
            if (set_data_float(($1 | 0x20), $2->result) == false) {
                gcode_data->decoded = false;
                printf("not decoded char %c, line %d\n", $1, gcode_lineno);
            }
        
            if ($2) {
                gcode_data->opVector << $2;
            }
//             gcode_data = new GCodeData(gcode_data);
            gcode_data->numberLine = gcode_lineno;
//             gcode_data-> new DataOperation();
//             gcode_lval.c_val = $1;
        }
        | PARAM_CHAR
        {
            // set the coords
        }
        ;


EXPR:   '[' EXPR ']' 
        {
            // root expression 
            $$ = $2;
        }
        | '[' EXPR '*' EXPR ']'
        {
            $$ = new DataOperation(EXP::MUL, DATA::FVAL);
            $$->expr1 = $2;
            $$->expr2 = $4;
            $$->result = $2->result * $4->result;
        }
        | '[' EXPR '/' EXPR ']'
        {
            $$ = new DataOperation(EXP::DIV, DATA::FVAL);
            $$->expr1 = $2;
            $$->expr2 = $4;
            $$->result = $2->result / $4->result;
        }
        | '[' EXPR '+' EXPR ']'
        {
            $$ = new DataOperation(EXP::PLUS, DATA::FVAL);
            $$->expr1 = $2;
            $$->expr2 = $4;
            $$->result = $2->result + $4->result;
        }
        | '[' EXPR '-' EXPR ']'
        {
            $$ = new DataOperation(EXP::MINUS, DATA::FVAL);
            $$->expr1 = $2;
            $$->expr2 = $4;
            $$->result = $2->result - $4->result;
        }
        | '-' EXPR %prec UMINUS 
        {
            $$ = new DataOperation(EXP::NEG, DATA::FVAL);
            $$->expr1 = $2; 
            $$->result = (-$2->result);
        }
        | SIN_FUNC '[' EXPR ']'
        {
            $$ = new DataOperation(EXP::SIN, DATA::FVAL);
            $$->expr1 = $3; 
            $$->result = qSin($3->result);
        }
        | COS_FUNC '[' EXPR ']'
        {
            $$ = new DataOperation(EXP::COS, DATA::FVAL);
            $$->expr1 = $3; 
            $$->result = qCos($3->result);
        }
        | SQRT_FUNC '[' EXPR ']'
        {
            $$ = new DataOperation(EXP::SQRT, DATA::FVAL);
            $$->expr1 = $3; 
            $$->result = qSqrt($3->result);
        }
        | '[' EXPR POW_FUNC EXPR ']'
        {
            $$ = new DataOperation(EXP::POW, DATA::FVAL);
            $$->expr1 = $2;
            $$->expr2 = $4;
            $$->result = qPow($2->result, $4->result);
        }
        | IVAL 
        {
            $$ = new DataOperation(EXP::NONE, DATA::FVAL);
            $$->result = (float)$1;
        }
        | FVAL 
        {
            $$ = new DataOperation(EXP::NONE, DATA::FVAL);
            $$->result = $1;
        }
        | VARIABLE 
        {
            $$ = new DataOperation(EXP::NONE, DATA::SVAL);
            
            if (GData::dataVaris.contains($1)){
                $$->vName = $1;
                $$->result = GData::dataVaris[$1];
            }
            else {
                qInfo() << $1 << "was not defined";
            }
        }
        ;
%%


bool set_data_float(char c, float f) {
    switch (c){
        case 'x':
            gcode_data->baseCoord.setX(f);
            break;
            
        case 'y':
            gcode_data->baseCoord.setY(f);
            break;
            
        case 'z':
            gcode_data->baseCoord.setZ(f);
            break;
            
        case 'i':
            gcode_data->useExtCoord = IJK; // TODO check conflicts
            gcode_data->extCoord.setX(f);
            break;
            
        case 'j':
            gcode_data->useExtCoord = IJK; // TODO check conflicts
            gcode_data->extCoord.setY(f);
            break;
            
        case 'k':
            gcode_data->useExtCoord = IJK; // TODO check conflicts
            gcode_data->extCoord.setZ(f);
            break;
            
        case 'a':
            gcode_data->useExtCoord = ABC; // TODO check conflicts
            gcode_data->extCoord.setX(f);
            break;
            
        case 'b':
            gcode_data->useExtCoord = ABC; // TODO check conflicts
            gcode_data->extCoord.setY(f);
            break;
            
        case 'c':
            gcode_data->useExtCoord = ABC; // TODO check conflicts
            gcode_data->extCoord.setZ(f);
            break;
            
        case 'u':
            gcode_data->useExtCoord = UVW; // TODO check conflicts
            gcode_data->extCoord.setX(f);
            break;
            
        case 'v':
            gcode_data->useExtCoord = UVW; // TODO check conflicts
            gcode_data->extCoord.setY(f);
            break;
            
        case 'w':
            gcode_data->useExtCoord = UVW; // TODO check conflicts
            gcode_data->extCoord.setZ(f);
            break;
            
        case 'r': // radius
            gcode_data->radius = f;
            break;
            
        case 's': // pause sec
            if (gcode_data->gCmd == 4){
                gcode_data->pauseMSec = f*1000.0;
            }
            break;
            
        case 'p': // pause msec
            if (gcode_data->gCmd == 4){
                gcode_data->pauseMSec = f;
            }
            break;
            
        case 'f': // feed
            gcode_data->rapidVelo = f;
            break;
            
        case 'd': // diameter
            gcode_data->toolDiameter = f;
            break;
            
        case 't': // change tool
            gcode_data->toolChange = true;
            gcode_data->toolNumber = f;
            break;
            
        default:
            gcode_data->decoded = false;
            printf("not decoded char %c, line %d\n", c, gcode_lineno);
            return false;
            break;
    }
    return true;
}


void gcode_error (const char * error) {
  fprintf (stderr, "line %d: %s\n", gcode_lineno, error);
//   return 0;
}
