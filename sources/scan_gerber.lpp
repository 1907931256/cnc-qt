/* -*-c-*- */

%{
/****************************************************************************
 * C# to Qt portation, Linux developing                                     *
 * flex/bison Gerber parser                                                 *
 * Copyright (C) 2015-2018 by Eduard Kalinowski                             *
 * Germany, Lower Saxony, Hanover                                           *
 * eduard_kalinowski@yahoo.de                                               *
 *                                                                          *
 * C# project CNC-controller-for-mk1                                        *
 * https://github.com/selenur/CNC-controller-for-mk1                        *
 *                                                                          *
 * The Qt project                                                           *
 * https://github.com/eduard-x/cnc-qt                                       *
 *                                                                          *
 * CNC-Qt is free software; may be distributed and/or modified under the    *
 * terms of the GNU General Public License version 3 as published by the    *
 * Free Software Foundation and appearing in the file LICENSE_GPLv3         *
 * included in the packaging of this file.                                  *
 *                                                                          *
 * This program is distributed in the hope that it will be useful,          *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of           *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            *
 * GNU General Public License for more details.                             *
 *                                                                          *
 * You should have received a copy of the GNU Lesser General Public         *
 * License along with CNC-Qt. If not, see  http://www.gnu.org/licenses      *
 ****************************************************************************/

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-register"
#endif

#if HAVE_CONFIG_H
# include <config.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#ifdef __MINGW32__
#include <io.h>
#endif

#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif



#if !HAVE_STRCHR
# define strchr  index
# define strrchr rindex
#endif


// this generated header file from parse_gerber.ypp
#include "parse_gerber.h"


#include "Settings.h"
#include "Gerber.h"

extern int gerber_lineno;
int gerber_charno = 1;

#define YY_USER_ACTION gerber_charno += gerber_leng; 

%}


WSPACE    [ \t\r]+
DIGITS    [0-9]+
COMMENT   \(.+\)
EXPONENT  [Ee][+-]?{DIGIT}+
INT       [+-]?{DIGITS}
REAL1     [+-]?{DIGITS}?[.]{DIGITS}
REAL2     [+-]?{DIGITS}[.]{DIGITS}?
EOL       \n

APPERTYPE [CROPM]
DICTNUM   \D{DIGITS}
FILENAME  [A-Z0-9_\-\.]+
INCH      \IN
MM        \MM
INFO      [A-Z]+\:
UNIT      {INCH}|{MM}
GRBBEG    \G0?4.*\*
GRBEND    \M0?2
MODE      \MO{UNIT}
DCODE     \D[0]?[123]
GCODE     \G[0]?[123]
QUAD      \G7
REGION    \G3
POS       \POS
NEG       \NEG
OPER      [\(\)]
NAME      [A-Z0-9]+

%x OPTION DATAFIELD

%option stack caseless yylineno noyywrap nounput noinput prefix="gerber_"


%%

<INITIAL>"%" {
    /* begin of options */
    yy_push_state(OPTION);
}

<OPTION>"%" {
    yy_pop_state();
}

<OPTION>{MODE} {
    if (gerber_text[2] == 'I' && gerber_text[3] == 'N') {
        return SET_INCH;
    }
    if (gerber_text[2] == 'M' && gerber_text[3] == 'M') {
        return SET_MM;
    }
}

<INITIAL,OPTION>"*" {
    /* end of data or separator between descriptor and followed datafield */
}

<INITIAL>{INFO} {
    qInfo() << gerber_text;
}

<INITIAL>{GRBBEG} {
    /* begin prog */
    qInfo() << gerber_text;
}

<INITIAL>{GRBEND} {
    /* end prog */
}

<INITIAL,OPTION>{WSPACE} {
    /* ignore spaces */
}

<INITIAL,OPTION>"," {
    /* separator in options */
}

<INITIAL>{DCODE} {
    gerber_lval.i_val = strtol(&gerber_text[1], NULL, 10);
    return D_OPCODE;
}

<INITIAL>{GCODE} {
    gerber_lval.i_val = strtol(&gerber_text[1], NULL, 10);
    return G_OPCODE;
}


<OPTION>\MI {
    return MIRRORING;
}

<OPTION>\A{INT}|{REAL1}|{REAL2} {
    gerber_lval.f_val = atof(&gerber_text[1]);
    return APARAM;
}

<OPTION>\B{INT}|{REAL1}|{REAL2} {
    gerber_lval.f_val = atof(&gerber_text[1]);
    return BPARAM;
}

<OPTION>\T[FAOD] {
    /* only attributes F, A, O, D */
    switch (gerber_text[1]) {
        case 'F': /* ATTRIBUTE */
            break;
        case 'A': /* APERTURE_ATTRIBUTE */
            break;
        case 'O': /* OBJECT_ATTRIBUTE */
            break;
        case 'D': /* DELETE_ATTRIBUTE */
            break;
    }
}

<OPTION>\FS[LT][AI] {
    /* L: OMIT_LEADING_ZEROS, T: OMIT_TRAILING_ZEROS, A: absolute, I: incremental */
    qInfo() << gerber_text;
    gerber_lval.s_val = strndup(&gerber_text[2], 2);
    return FMT;
}

<OPTION>\SF {
}

<OPTION>\LN{FILENAME} {
    /* name ? */
}

<OPTION>\AM{NAME} {
    /* aperture macro */
    gerber_lval.s_val = strdup(&gerber_text[2]);
    return APER_MACRO_NAME;
}

<OPTION>\AD{DICTNUM}{NAME}? {
    /* aperture dictionary */
    gerber_lval.s_val = strdup(&gerber_text[2]);
    return APER_DICTIONARY;
}

<OPTION>\IP{POS}|{NEG} {
    /* image polarity */ 
    if (gerber_text[2] == 'P') {
        return POSITIVE;
    }
    else {
        return NEGATIVE;
    }
}

<OPTION>\LP[DC] {
    /* level polarity */
    if (gerber_text[2] == 'D') {
        return POSITIVE;
    }
    else {
        return NEGATIVE;
    }
}

<INITIAL>\G54{DICTNUM} {
    gerber_lval.s_val = strdup(&gerber_text[3]);
    return APER_SELECT;
}

<INITIAL,OPTION>{OPER} {
    /* ignore '(' and ')' */
}


<OPTION>\G9[01] {
    /* 0 is abs 1 is rel */ 
    if (gerber_text[2] == '0') {
        return ABS;
    }
    else {
        return REL;
    }
}

{QUAD} {
    /* quadr */
}

{REGION}[67]"*" {
    /* region 6 is ON, 7 is OFF */
    if (gerber_text[2] =='6'){
    }
    else {
    }
}

<OPTION>\SR {
}

<INITIAL,OPTION>{INT} {
    gerber_lval.i_val = strtol(gerber_text, NULL, 10);
    return INTEGER;
}

<INITIAL,OPTION>{REAL1}|{REAL2} {
    std::string s = gerber_text;
    std::replace( s.begin(), s.end(), Settings::toDecimalPoint, Settings::fromDecimalPoint);
    gerber_lval.f_val = atof(s.c_str());
    
    return FLOAT;
}

<INITIAL,OPTION>\X {
    return XPARAM;
}

<INITIAL,OPTION>\Y {
    return YPARAM;
}

<INITIAL,OPTION>\I {
    return IPARAM;
}

<INITIAL,OPTION>\J {
    return JPARAM;
}

<INITIAL,OPTION>{EOL} {
    gerber_charno = 1;
}


<*>. { /* any other character is invalid */
  fprintf (stderr,
       "line %d pos %d: syntax error, unrecognized character: `%s'\n", gerber_lineno, gerber_charno, gerber_text);
   return InvalidCharacter;
}

%%

                  
